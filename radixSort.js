// * 기수정렬, 계수정렬
/*
  radix sort, 기수정렬
  https://www.youtube.com/watch?v=XiuSW_mEn7g (기수 정렬에 대한 유튜브 강의)
  https://taesung1993.tistory.com/32 (블로그 설명)
  기수정렬은 버킷 안에 자리수별로 넣어서 비교하는 방식이라고 생각하면 된다. 
  계수정렬을 바탕으로 한다고 생각하면 쉬울 것 같다. 
  예를 들면 [22,51,14,166,31,72]이 있다고 하면, 일의 자리수부터 비교한다. 
  [51, 31],[22, 72], [14], [166] 이렇게 나눠질거고, 그리고 이후 10의 자리를 비교한다. 
  [14], [22], [31], [51], [166], [72] 그리고 100의 자리를 비교하면
  [14, 22, 31, 51, 72, 166] 이렇게 될 것. 그러나 이 과정에 계수정렬이 들어감. 


  counting sort, 계수정렬
  계수정렬은 크기를 기준으로 카운팅 한다고 생각하면 됨. 아래 코드는 1-5까지의 숫자를 가지고 계수정렬을 했음. 
  그러나 그 크기가 1000이 되면 1000까지 메모리를 만들어야 하므로, 메모리 낭비가 심할 수 있음 
  시간복잡도는 O(N)
  https://taesung1993.tistory.com/30?category=868017
 */

// * 계수정렬 코드
const arr = [5, 4, 2, 5, 3, 2, 1, 3, 2, 3, 1, 4]
const count = Array(Math.max(...arr)).fill(0);

let sorted = [];

for (let i = 0; i < arr.length; i++){
  count[arr[i] - 1]++;
  console.log(count)
}

for (let j = 0; j < count.length; j++) {
  const sortednum = Array(count[j]).fill(j + 1)
  sorted = sorted.concat(sortednum);
}

console.log(sorted)

/* 
count는 이렇게 들어가게 됨
[ 0, 0, 0, 0, 1 ]
[ 0, 0, 0, 1, 1 ]
[ 0, 1, 0, 1, 1 ]
[ 0, 1, 0, 1, 2 ]
[ 0, 1, 1, 1, 2 ]
[ 0, 2, 1, 1, 2 ]
[ 1, 2, 1, 1, 2 ]
[ 1, 2, 2, 1, 2 ]
[ 1, 3, 2, 1, 2 ]
[ 1, 3, 3, 1, 2 ]
[ 2, 3, 3, 1, 2 ]
[ 2, 3, 3, 2, 2 ]

그리고 이 카운팅을 통해서, 0번 인덱스는 1을 의미하므로, [1,1], 
1번 인덱스는 2를 의미하므로, [1,1,2,2,2]
이런 식으로 sorted가 완성
 */


// * 토이 문제 기수정렬 레퍼런스 코드 (이해했으나 외워서 다시 써보자) => 이틀 뒤에!
